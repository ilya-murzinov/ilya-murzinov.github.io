# Speech

Всем привет, меня зовут Илья, я бэкенд-разработчик в компании Револют.
Я хочу рассказать про библиотеку Моникс для функционального и реактивного программирования.
В конце доклада за лучшие вопросы я подарю вот такую классную толстовку.

Но для начала пара слов про Револют: мы - финтех-стартап с головным офисом в Лондоне, а так же
офисами разработки в Питере, Москве и Кракове.

Мы делаем цифровой банк, в котором счёт можно открыть за минуты, курсы валют всегда самые выгодные, а
международные переводы вообще бесплатные.

Проекты у нас в основном написаны на джаве, но есть несколько проектов на скале, одним из которых мне
посчастливилось заниматься. Это проект "чат" - АПИшка для общения между саппорт-агентами и юзерами.

Я говорю "посчастливилось", потому что это, наверное, пока единственный наш проект, написанный в чисто
функциональном стиле, который лично мне очень близок. И, конечно, у нас используется Моникс, иначе бы
я тут не стоял.

А поднимите, пожалуйста, руку те, кто пишет (старается писать) в функциональном стиле?
А кто вообще знает, что такое чисто функциональный стиль?

Я для себя определил функциональный стиль как отсутствие функций с сайд-эффектами. Функции без
сайд-эффектов ещё называют ссылочно прозрачными. Я немного позже поясню, что это такое.

Функциональный стиль написания кода даёт много преимуществ, главным из которых для меня, как для
разработчика, является возможность не думать про контекст выполнения функции а так же возможность
рефакторить код не опасаясь, что я что-то сломаю.

Давайте перейдём непосредственно к обзору Моникса и посмотрим какие абстракции он предлагает и как с
ними работать.

Как я уже сказал, Моникс - это библиотека для функционального и реактивного программирования. Но на
самом деле это 3 небольшие библиотечки, у каждой из которых своя функция. Это полезно, чтобы добавлять
в проект только те зависимости, которые необходимы.

Пройдёмся по каждой библиотечке и посмотрим, что она содержит.

monix-eval - основная библиотека для описания вычислений. Предоставляет такие абстракции как Task,
Coeval, MVar
monix-reactive - Observable/Observer
monix-tail - Iterant (pull-based stream)
monix-execution - внутренний модуль, содержит Scheduler и кучу классов внутреннего АПИ (например
свои атомики). Предназначен для выполнения описанных вычислений. От этого модуля зависят все остальные.

Ключевой абстракцией является Task - структура данных, которая позволяет описывать вычисления,
возможно, асинхронные. Для начала хочу пояснить, зачем вообще нужен Task, когда у нас вроде бы уже
есть Future, которая позволяет описывать асинхронные вычисления.

Дело в том, что между Task и Future есть значительные принципиальне различия, давайте на них посмотрим.

Главная проблема Future в том, что она жадная, это значит, что когда вы в своём коде получили ссылку
на какую-то Future, то скорее всего она уже начала выполняться, а может быть даже завершила выполнение.
Это нарушает ссылочную прозрачность Future, то есть банальный рефакторинг ТАКОГО ВИДА полностью меняет
семантику программы.

Кроме того, запущенное внутри Future вычисление невозможно отменить, даже если результат нам уже не
нужен. То есть отменить-то его можно, но для этого придётся делать кастомную логику в самом вычислении.

С точки зрения выполнения, Future всегда запускается на другом логическом потоке, что может привести к
оверхеду из-за переключения контекста, хотя в некоторых случаях этого можно было бы избежать.

С другой стороны Task является ленивым, то есть пока на нём не вызван runAsync, ничего не будет
выполнено. На таск можно смотреть как на чистую функцию, которая возвращает Future. Это делает его
ссылочно прозрачным, а значит программу, составленную из тасков, гораздо проще поддерживать.

Таск можно сделать отменяемым, причём почти автоматически, просто вызвав cancelable. Чуть позже я
поясню, как это работает.

Таск не всегда запускается на другом логическом потоке и позволяет очень точно контролировать своё
выполнение, например, выполнять часть задач на отдельном тред-пуле, либо форсировать переключение на
другой логический поток.

Хочу перейти к примерам, но придётся сначала поговорить про Scheduler, потому что без него таск не
запустить. Scheduler - это ExecutionContext с дополнительными возможностями.

Он умеет:
Запускать отложенную задачу
Запускать задачу периодически
Предоставлять текущее время
Предоставлять cancellation token для отмены запланированной задачи
Использовать разные модели выполнения

С первыми 4 пунктами всё должно быть понятно, про последний поясню.
В Моникс существуют 3 модели выполнения задач - AlwaysAsyncExecution,
SynchronousExecution и BatchedExecution.
AlwaysAsyncExecution - модель выполнения, которая соответстует аналогична Future, то есть всегда
форкает тред.
SynchronousExecution - всегда запускает таски на том же потоке, если явно не указано обратное.
По дефолту используется последняя модель выполнения, то есть BatchedExecution, которая запускает таски
на одном потоке батчами определённого размера, после чего шифтится на другой поток.

Давайте наконец-то посмотрим, как создавать таск. После всего, что я рассказал, это должно быть совсем
понятно.