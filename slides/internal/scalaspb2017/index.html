<!DOCTYPE html>
<html>
  <head>
    <title>Typelevel computations with Scala</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../../../css/all.css">
    <link rel="stylesheet" href="../../../css/hack-subset.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);

      @page {
        size: 1210px 681px;
        margin: 0;
      }

      @media print {
        .remark-slide-scaler {
          width: 100% !important;
          height: 100% !important;
          transform: scale(1) !important;
          top: 0 !important;
          left: 0 !important;
        }
      }

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Hack'; }
      .hljs-github .hljs-comment, .hljs-github .hljs-quote { font-style: normal; }
      a:link { color: grey; }
      a:visited { color: grey; }
      a:hover { color: grey; }
      a:active { color: grey; }

      img {
        display: block;
        margin: auto;
      }

      .inverse {
        background: #272822;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      div.my-header {
        font-family: 'Yanone Kaffeesatz';
        font-size: 15pt;
        position: fixed;
        top: 10px;
        left: 15px;
        height: 30px;
        width: 100%;
        text-align: left;
      }

      div.my-footer {
        position: absolute;
        bottom: 0px;
        left: 0px;
        height: 20px;
        width: 100%;
      }

      div.my-footer span {
        font-family: 'Yanone Kaffeesatz';
        font-size: 15pt;
        position: absolute;
        left: 15px;
        bottom: 12px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: middle, center

# Typelevel computations with Scala

### Ilya Murzinov

[https://twitter.com/ilyamurzinov](https://twitter.com/ilyamurzinov)

[https://github.com/ilya-murzinov](https://github.com/ilya-murzinov)

.bottom[[https://ilya-murzinov.github.io/slides/scalaspb2017](https://ilya-murzinov.github.io/slides/scalaspb2017.pdf)]

---

class: middle, center

<img src="../../../images/Revolut.png" style="max-width:100%;" />

---

class: middle, center

# Why?

???
We love types for being able to catch errors in compile time

Maybe you have heard that Scala typesystem is Turing complete, therefore,
we can run arbitrary computations in compile-time

It's interesting how exactly meaningful computations can be implemented and
how far we go with it

---

# We can do amazing things in Haskell

<img src="../../../images/scalaspb2017/typing-the-technical-interview.png" height="400px" />

???
Staring with Haskell is never good, but I'll try to keep it simple

There will be no mentions of Monad except this one, honestly

Kyle Kingsbury

Distributed system correctness

---

# N queens problem

<img src="../../../images/scalaspb2017/nqueens.jpg" height="450px" />

???
Problem is to find ALL solutions for given N

---

# Algorithm

<img src="../../../images/scalaspb2017/nqueens-algorithm.gif" height="450px" />

???
Algorithm - recursively for every queen in row check if it's safe,
then add it and move to the next row

---

# What we need for solution

- Natural numbers
--

- Lists
--

- Booleans
--

- Functions
--

- **The way to operate with all above**
---

# Natural numbers

```scala
trait Nat
trait Z extends Nat
trait Succ[N <: Nat] extends Nat
```
--

```scala
type _0 = Z
type _1 = Succ[_0]
type _2 = Succ[_1]
type _3 = Succ[_2]
type _4 = Succ[_3]
type _5 = Succ[_4]

// and so on
```

---

# Typelevel functions

```scala
trait Nat {
  type Add[A <: Nat]
}
```
--

```scala
trait Z extends Nat {
  type Add[A <: Nat] = A
}
```
--

```scala
trait Succ[N <: Nat] extends Nat {
  type Add[A <: Nat] = `Succ[Z#Add[A]]`
}
```

---

# Typeclasses
--

```scala
def print[A](a: A)(implicit e: Encoder[A]): String = e.print(a)
```
--

```scala
scala> print(42)
42
```
--

Deep down in some imported library:

```scala
trait Encoder { // <-- typeclass
  def print[A](a: A)
}

implicit val encoder = new Encoder[Int] {
  def print(i: Int) = i.toString
}
```

???
This is a trivial case

Scala compiler can resolve complex implicits
by dividing them into simple ones

Out typeclasses will not have value-level methods

---

# The Add typeclass

```scala
class Add[A, B] { type Out }
```

???
Type bounds are left hereinafter

Type member is like type parameter

Think of it as a result and type parameters as arguments
--

```scala
implicit def a0[A]: Add[`_0`, A] { type Out = A } = `???`
```
--

```scala
implicit def a1[A]: Add[A, `_0`] { type Out = A } = ???
```
--

```scala
implicit def a2[A, B, C](implicit
  a: `Add[A, B] { type Out = C }`
): `Add[Succ[A], B] { type Out = Succ[C] }` = ???
```

---

# How to use it
--

```scala
def implicitly[A](implicit a: A) = a
```
--

```scala
scala> implicitly[Add[_1, _2]]
scala.NotImplementedError: an implementation is missing
	at scala.Predef