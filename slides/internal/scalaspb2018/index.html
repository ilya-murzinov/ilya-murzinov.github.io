<!DOCTYPE html>
<html>
  <head>
    <title>Monix in practice</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../../../css/all.css">
    <link rel="stylesheet" href="../../../css/hack-subset.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);

      @page {
        size: 1210px 681px;
        margin: 0;
      }

      @media print {
        .remark-slide-scaler {
          width: 100% !important;
          height: 100% !important;
          transform: scale(1) !important;
          top: 0 !important;
          left: 0 !important;
        }
      }

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Hack'; }
      .hljs-github .hljs-comment, .hljs-github .hljs-quote { font-style: normal; }
      a:link { color: grey; }
      a:visited { color: grey; }
      a:hover { color: grey; }
      a:active { color: grey; }

      img {
        display: block;
        margin: auto;
      }

      .inverse {
        background: #272822;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      div.my-header {
        font-family: 'Yanone Kaffeesatz';
        font-size: 15pt;
        position: fixed;
        top: 10px;
        left: 15px;
        height: 30px;
        width: 100%;
        text-align: left;
      }

      div.my-footer {
        position: absolute;
        bottom: 0px;
        left: 0px;
        height: 20px;
        width: 100%;
      }

      div.my-footer span {
        font-family: 'Yanone Kaffeesatz';
        font-size: 15pt;
        position: absolute;
        left: 15px;
        bottom: 12px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

<img src="../../../images/monix-logo.png" width="100" />

# Monix in practice

### Ilya Murzinov

[https://twitter.com/ilyamurzinov](https://twitter.com/ilyamurzinov)

[https://github.com/ilya-murzinov](https://github.com/ilya-murzinov)

Slides: [https://ilya-murzinov.github.io/slides/scalaspb2018.pdf](https://ilya-murzinov.github.io/slides/scalaspb2018.pdf)

---

layout: true
<div class="my-footer"><span>Monix in practice - Ilya Murzinov, slides: <a href="https://ilya-murzinov.github.io/slides/scalaspb2018.pdf">https://ilya-murzinov.github.io/slides/scalaspb2018.pdf</a></span></div>

---

class: middle, center

<img src="../../../images/Revolut.png" style="max-width:100%;" />

???
Но для начала пара слов про Револют: мы - финтех-стартап с головным офисом в Лондоне, а так же
офисами разработки в Питере, Москве и Кракове.

Мы делаем цифровой банк, в котором счёт можно открыть за минуты, курсы валют всегда самые выгодные, а
международные переводы вообще бесплатные.

Проекты у нас в основном написаны на джаве, но есть несколько проектов на скале, одним из которых мне
посчастливилось заниматься. Это проект "чат" - АПИшка для общения между саппорт-агентами и юзерами.

Я говорю "посчастливилось", потому что это, наверное, пока единственный наш проект, написанный в чисто
функциональном стиле, который лично мне очень близок. И, конечно, у нас используется Моникс, иначе бы
я тут не стоял.

А поднимите, пожалуйста, руку те, кто пишет (старается писать) в функциональном стиле?
А кто вообще знает, что такое чисто функциональный стиль?

Я для себя определил функциональный стиль как отсутствие функций с сайд-эффектами. Функции без
сайд-эффектов ещё называют ссылочно прозрачными.

Ссылочно прозрачная функция - это такая функция, вызов которой можно заменить на результат
её выполнения без изменения семантики программы.

---

# Referential transparency

```scala
def goodFunction() = 2 + 2
```

--

```scala
def badFunction() = {
  sendMessage()
  2 + 2
}
```

???
Функциональный стиль написания кода даёт много преимуществ

не думать про контекст выполнения функции

рефакторить код не опасаясь, что я что-то сломаю.

---
class: middle, center

<img src="../../../images/monix-logo.png" width="100" />

# Monix

???
Как я уже сказал, Моникс - это библиотека для функционального и реактивного программирования.

Но на самом деле это аж 4 небольшие библиотечки, у каждой из которых своя функция.

---

# Monix modules

- `monix-eval` - Task, Coeval, MVar etc.

- `monix-reactive` - Observable, Observer (push-based streaming)

- `monix-tail` - Iterant (pull-based streaming)

- `monix-execution` - Scheduler & bunch of performance hacks

---
class: middle, center

# `Task[A]`

???
Ключевой абстракцией является Task - структура данных, которая позволяет описывать вычисления,
возможно, асинхронные. Для начала хочу пояснить, зачем вообще нужен Task, когда у нас вроде бы уже
есть Future, которая позволяет описывать асинхронные вычисления.

Дело в том, что между Task и Future есть значительные принципиальне различия, давайте на них посмотрим.

---

# Task vs Future
--

`scala.concurrect.Future`:

- Eager (thus not ref. transparent)

???
Главная проблема Future в том, что она жадная, это значит, что когда вы в своём коде получили ссылку
на какую-то Future, то скорее всего она уже начала выполняться, а может быть даже завершила выполнение.
Это нарушает ссылочную прозрачность Future, то есть банальный рефакторинг ТАКОГО ВИДА полностью меняет
семантику программы.
--

- Not cancellable

???
Кроме того, запущенное внутри Future вычисление невозможно отменить, даже если результат нам уже не
нужен. То есть отменить-то его можно, но для этого придётся делать кастомную логику в самом вычислении.
--

- Always asyncronous

???
С точки зрения выполнения, Future всегда запускается на другом логическом потоке, что может привести к
оверхеду из-за переключения контекста, хотя в некоторых случаях этого можно было бы избежать.
--

- Not stack-safe

--

`monix.Task`:

- Lazy (ref. transparent)

???
С другой стороны Task является ленивым, то есть пока на нём не вызван runAsync, ничего не будет
выполнено. На таск можно смотреть как на чистую функцию, которая возвращает Future. Это делает его
ссылочно прозрачным, а значит программу, составленную из тасков, гораздо проще поддерживать.
--

- Cancellable

???
Таск можно сделать отменяемым, причём почти автоматически, просто вызвав cancelable. Чуть позже я
поясню, как это работает.
--

- Not always asyncronous

???
Таск не всегда запускается на другом логическом потоке и позволяет очень точно контролировать своё
выполнение, например, выполнять часть задач на отдельном тред-пуле, либо форсировать переключение на
другой логический поток.
--

- Stack (and heap) safe

---

# Scheduler

- Schedule delayed execution

- Schedule periodic execution

- Provide cancellation token

- Use different execution models

---

# ExecutionModel

- `AlwaysAsyncExecution`

- `SynchronousExecution`

- `BatchedExecution`

---

# Scheduler

```scala
Scheduler.computation(name = "my-computation")

Scheduler.io(name = "my-io")
```

???
computation под капотом имеет ForkJoinPool и предназначен в основном для CPU-bound вычислений.

у io под капотом unbounded CachedThreadPool.

--
```scala
Scheduler.fixedPool("my-fixed-pool", 10)

Scheduler.singleThread("my-single-thread")
```

---
# Creating a task

```scala
import monix.eval.Task

// eagerly evaluates the argument
Task.now(42)
Task.now(println(42))

// suspends argument evaluation
Task.eval(println(42))

// suspends evaluation + makes it asynchronous
Task(println(42))

...

Task.evalOnce(...)
Task.defer(...)
Task.deferFuture(...)
Task.deferFutureAction(...)

...

```

---

# Thread shifting

```scala
val t = Task.eval(println(42))

t.executeAsync

t.executeOn(io)

t.asyncBoundary(io)
```

---

# Thread shifting

```scala
import monix.execution.Scheduler
import monix.execution.Scheduler.Implicits.global

lazy val io = Scheduler.io(name = "my-io")

val source = Task.eval(println(
  s"Running on thread: 